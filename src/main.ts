const allConstants = require('./constants.ts');

module.exports = {
    WeakPasswordChecker:  (rawPassword: string, passwordLength: number) => {
        let status = true;

        try {
            if (!rawPassword || !passwordLength) {
                return !status;
            } else {
                try {
                    if (!(passwordLength === rawPassword.length && passwordLength >= 10)) {
                        return !status;
                    } else {
                        allConstants.getCommonWords().forEach((word) => {
                            if (rawPassword.toString().toLowerCase().includes(word)) {
                                status = false;
                            }
                        });

                        if (status) {

                            const pattern = new RegExp(
                                "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[-+_!@#$%^&*.,?]).+$"
                            );
                            if (pattern.test(rawPassword)) {
                                return status;
                            } else {
                                return !status;
                            }
                        }
                        return status;
                    }
                } catch (e) {
                    console.log("SecurePasswordUtility::: ", e.message);
                }
            }
        } catch (e) {
            console.log("SecurePasswordUtility::: ", e.message);
            return status;
        }
    },
    StrongPasswordGenerator:  (passwordLength) => {
        let uCaseLength = 0;
        let lCaseLength = 0;
        let nCaseLength = 0;
        let cCaseLength = 0;
        let remainder = 0;

        let autoGeneratedPassword = "", upperCaseGenerator = "", lowerCaseGenerator = "";
        let numericGenerator = "", characterGenerator = "", optionalCharacter = "", scrambledPassword = "";

        if (passwordLength.isNaN || passwordLength <= 11) {
            return "Invalid input";
        }
        if ((parseInt(passwordLength) % 4 !== 0)) {
            remainder = parseInt(passwordLength) % 4;
            uCaseLength = (passwordLength - remainder) / 4;
            lCaseLength = (passwordLength - remainder) / 4;
            nCaseLength = (passwordLength - remainder) / 4;
            cCaseLength = (passwordLength - remainder) / 4;
        } else {
            uCaseLength = passwordLength / 4;
            lCaseLength = passwordLength / 4;
            nCaseLength = passwordLength / 4;
            cCaseLength = passwordLength / 4;
        }


        for (let i = 0; i < uCaseLength; i++) {
            upperCaseGenerator += allConstants.getUpperCase().charAt(Math.floor(Math.random() *
                allConstants.getUpperCase().length));
        }

        for (let j = 0; j < lCaseLength; j++) {
            lowerCaseGenerator += allConstants.getLowerCase().charAt(Math.floor(Math.random() *
                allConstants.getLowerCase().length));
        }

        for (let k = 0; k < nCaseLength; k++) {
            numericGenerator += allConstants.getAllNumbers().charAt(Math.floor(Math.random() *
                allConstants.getAllNumbers().length));
        }

        for (let z = 0; z < cCaseLength; z++) {
            characterGenerator += allConstants.getSpecialChars().charAt(Math.floor(Math.random() *
                allConstants.getSpecialChars().length));
        }

        scrambledPassword = upperCaseGenerator + lowerCaseGenerator + numericGenerator + characterGenerator;

        if (remainder !== 0) {
            for (let x = 0; x < remainder; x++) {
                optionalCharacter += allConstants.getRandomString().charAt(Math.floor(Math.random() *
                    allConstants.getRandomString().length));
            }
            scrambledPassword = scrambledPassword.toString().concat(optionalCharacter);
            return this.CompletePasswordGeneration(passwordLength, autoGeneratedPassword, scrambledPassword);
        } else {
            return this.CompletePasswordGeneration(passwordLength, autoGeneratedPassword, scrambledPassword);
        }
    },
    CompletePasswordGeneration: (passwordLength: number, autoGeneratedPassword: any, scrambledPassword) => {
        for (let b = 0; b < passwordLength; b++) {
            autoGeneratedPassword += scrambledPassword.charAt(Math.floor(Math.random() *
                scrambledPassword.length));
        }
        return autoGeneratedPassword;
    },
    CreateStrongPassword: (codeLength) => {
        if (codeLength.isNaN || codeLength <= 11 || codeLength >= 50) {
            return "Invalid input";
        }
        let createNewPassword = this.StrongPasswordGenerator(codeLength);
        if (this.WeakPasswordChecker(createNewPassword, codeLength)) {
            return createNewPassword;
        } else {
            createNewPassword = this.CreateStrongPassword(codeLength);
        }
        return createNewPassword;
    },
    ProductKeyGenerator: (productKeyLength) => {
        let generatedProductKey = "";
        let finalGeneratedProductKey = "";
        let modulusSum = 0;
        if (!productKeyLength.isNaN && productKeyLength >= 16 && productKeyLength <= 100
            && (productKeyLength % 4 === 0 || productKeyLength % 5 === 0)) {
            const upperCase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456890';
            for (let i = 0; i < productKeyLength; i++) {
                generatedProductKey += upperCase.charAt(Math.floor(Math.random() *
                    upperCase.length));
            }
            if ((productKeyLength % 5 === 0 && productKeyLength % 4 === 0) || productKeyLength % 5 === 0) {
                for (let k = 0; k < productKeyLength; k++) {
                    modulusSum = k + 1;
                    if (modulusSum % 5 === 0) {
                        finalGeneratedProductKey += generatedProductKey.substring(k - 4, k + 1) + "-";
                    }
                }
            }
            if (productKeyLength % 4 === 0 && productKeyLength % 5 !== 0) {
                for (let l = 0; l < productKeyLength; l++) {
                    modulusSum = l + 1;
                    if (modulusSum % 4 === 0) {
                        finalGeneratedProductKey += generatedProductKey.substring(l - 3, l + 1) + "-";
                    }
                }
            }
        }
        finalGeneratedProductKey = finalGeneratedProductKey.substring(0, finalGeneratedProductKey.length - 1);
        return finalGeneratedProductKey;
    },
}

let common_header = require('./common/header.ts');

module.exports = {

    async weakPasswordChecker(userPassword, userPasswordLength) {
        let rawPassword = userPassword.toString();
        let passwordLength = parseInt(userPasswordLength);

        let status = true;
        const fileResult = new Set();

        try {
            if (!rawPassword || !passwordLength) {
                status = false;
            } else {
                try {
                    if (!(passwordLength === rawPassword.length && passwordLength >= 12)) {
                        status = false;
                    } else {
                        await fetch(common_header.getAllConstants().getRemotePassFile())
                            .then((response) => response.json())
                            .then(
                                (json) => json.forEach((word) => {
                                            if (rawPassword.toLowerCase().includes(word) && word.toString().toLowerCase().length >= 3) {
                                                fileResult.add(true);
                                            }
                                })
                            );
                                if (fileResult.size>0) {
                                    const pattern = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[-+_!@#$%^&*.,?]).+$/;
                                    if (!pattern.test(rawPassword)) {
                                        status = false;
                                        fileResult.add(true);
                                    }
                                }
                    }
                } catch (exception) {
                    console.log("SecurePasswordUtility::: ", exception.message);
                }
            }
        } catch (exception) {
            console.log("SecurePasswordUtility::: ", exception.message);
        }
        if(fileResult.size>0) {
            status = false;
        }
        return status
    },

    completePasswordGeneration(userPasswordLength, autoGeneratedPassword, obfuscatedPassword) {
        let scrambledPassword = common_header.getAllUtils().stringCaster(obfuscatedPassword);
        let passwordLength = common_header.getAllUtils().inputValidator(userPasswordLength)
        for (let b = 0; b < passwordLength; b++) {
            autoGeneratedPassword += scrambledPassword.charAt(Math.floor(Math.random() *
                scrambledPassword.length));
        }
        return autoGeneratedPassword;
    },

    strongPasswordGenerator(userPasswordLength) {
        let errorMessage = 'Invalid input';
        let passwordLength = common_header.getAllUtils().inputValidator(userPasswordLength)
        let uCaseLength = 0;
        let lCaseLength = 0;
        let nCaseLength = 0;
        let cCaseLength = 0;
        let remainder = 0;

        let autoGeneratedPassword = "", upperCaseGenerator = "", lowerCaseGenerator = "";
        let numericGenerator = "", characterGenerator = "", optionalCharacter = "", scrambledPassword = "";

        if (passwordLength <= 11) {
            return errorMessage;
        }
        if ((parseInt(passwordLength) % 4 !== 0)) {
            remainder = parseInt(passwordLength) % 4;
            uCaseLength = (passwordLength - remainder) / 4;
            lCaseLength = (passwordLength - remainder) / 4;
            nCaseLength = (passwordLength - remainder) / 4;
            cCaseLength = (passwordLength - remainder) / 4;
        } else {
            uCaseLength = passwordLength / 4;
            lCaseLength = passwordLength / 4;
            nCaseLength = passwordLength / 4;
            cCaseLength = passwordLength / 4;
        }


        for (let i = 0; i < uCaseLength; i++) {
                upperCaseGenerator += common_header.getAllConstants().getUpperCase().charAt(Math.floor(Math.random() *
                    common_header.getAllConstants().getUpperCase().length));
        }

        for (let j = 0; j < lCaseLength; j++) {
                lowerCaseGenerator += common_header.getAllConstants().getLowerCase().charAt(Math.floor(Math.random() *
                    common_header.getAllConstants().getLowerCase().length));
        }

        for (let k = 0; k < nCaseLength; k++) {
                numericGenerator += common_header.getAllConstants().getAllNumbers().charAt(Math.floor(Math.random() *
                    common_header.getAllConstants().getAllNumbers().length));
        }

        for (let z = 0; z < cCaseLength; z++) {
            characterGenerator += common_header.getAllConstants().getSpecialChars().charAt(Math.floor(Math.random() *
                common_header.getAllConstants().getSpecialChars().length));
        }

        scrambledPassword = upperCaseGenerator + lowerCaseGenerator + numericGenerator + characterGenerator;

        if (remainder !== 0) {
            for (let x = 0; x < remainder; x++) {
                optionalCharacter += common_header.getAllConstants().getRandomString().charAt(Math.floor(Math.random() *
                    common_header.getAllConstants().getRandomString().length));
            }
            scrambledPassword = scrambledPassword.toString().concat(optionalCharacter);
            return this.completePasswordGeneration(passwordLength, autoGeneratedPassword, scrambledPassword);
        } else {
                return this.completePasswordGeneration(passwordLength, autoGeneratedPassword, scrambledPassword);
        }
    },

    async createStrongPassword(passcodeLength) {
        let codeLength = common_header.getAllUtils().inputValidator(passcodeLength)
        if (codeLength <= 11 || codeLength >= 50) {
            return "Invalid input";
        }
        let createNewPassword = this.strongPasswordGenerator(codeLength);

        await this.weakPasswordChecker(createNewPassword, codeLength).then((result) => {
            if (!result) {
                return createNewPassword;
            } else {
                createNewPassword = this.createStrongPassword(codeLength);
            }
        })
        return this.strongPasswordGenerator(codeLength);
    },

    productKeyGenerator(rawProductKeyLength) {
        let productKeyLength = common_header.getAllUtils().inputValidator(rawProductKeyLength);
        let generatedProductKey = "";
        let finalGeneratedProductKey = "";
        let modulusSum = 0;
        if (productKeyLength >= 16 && productKeyLength <= 100
            && (productKeyLength % 4 === 0 || productKeyLength % 5 === 0)) {
            const upperCase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456890';
            for (let i = 0; i < productKeyLength; i++) {
                generatedProductKey += upperCase.charAt(Math.floor(Math.random() *
                    upperCase.length));
            }
            if ((productKeyLength % 5 === 0 && productKeyLength % 4 === 0) || productKeyLength % 5 === 0) {
                for (let k = 0; k < productKeyLength; k++) {
                    modulusSum = k + 1;
                    if (modulusSum % 5 === 0) {
                        finalGeneratedProductKey += generatedProductKey.substring(k - 4, k + 1) + "-";
                    }
                }
            }
            if (productKeyLength % 4 === 0 && productKeyLength % 5 !== 0) {
                for (let l = 0; l < productKeyLength; l++) {
                    modulusSum = l + 1;
                    if (modulusSum % 4 === 0) {
                        finalGeneratedProductKey += generatedProductKey.substring(l - 3, l + 1) + "-";
                    }
                }
            }
        }
        finalGeneratedProductKey = finalGeneratedProductKey.substring(0, finalGeneratedProductKey.length - 1);
        return finalGeneratedProductKey;
    }
}
